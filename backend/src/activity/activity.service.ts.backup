import { ForbiddenException, Injectable, NotFoundException } from '@nestjs/common';
import { InjectModel } from '@nestjs/mongoose';
import { Model, Types } from 'mongoose';
import { Activity, ActivityDocument } from './schema/activity.schema';
import { ActivityAssignment } from '../activity-assignment/schema/activity-assignment.schema';
import { ActivityAssignmentService } from '../activity-assignment/activity-assignment.service';
import { CreateActivityDto } from './dto/create-activity.dto';
import { UpdateActivityDto } from './dto/update-activity.dto';
import { JwtPayload } from '../auth/types/auth.type';
import { Role } from '../auth/types/auth.enum';
import { Student, StudentDocument } from '../student/schema/student.schema';
import { ActivityType } from '../activity-type/schema/activity-type.schema';

interface FindActivitiesFilter {
	status?: string;
	activityTypeId?: string;
}

@Injectable()
export class ActivityService {
	constructor(
		@InjectModel(Activity.name) private readonly activityModel: Model<ActivityDocument>,
		@InjectModel(ActivityAssignment.name)
		private readonly activityAssignmentModel: Model<ActivityAssignment>,
		@InjectModel(Student.name)
		private readonly studentModel: Model<StudentDocument>,
		@InjectModel(ActivityType.name)
		private readonly activityTypeModel: Model<ActivityType>,
		private readonly activityAssignmentService: ActivityAssignmentService,
	) {}

	async create(dto: CreateActivityDto, user: JwtPayload) {
		if (user.role !== Role.Student) {
			throw new ForbiddenException('Only students can create activities');
		}

		const student = await this.studentModel.findById(user.studentId).exec();
		if (!student || student.instituteId.toString() !== user.instituteId) {
			throw new ForbiddenException('Invalid student or institute context');
		}

		// Fetch ActivityType to validate details against formSchema
		const activityType = await this.activityTypeModel.findById(dto.activityTypeId).exec();
		if (!activityType) {
			throw new NotFoundException('ActivityType not found');
		}

		// Validate details against ActivityType's formSchema
		const details = dto.details || {};
		if (activityType.formSchema && activityType.formSchema.length > 0) {
			for (const field of activityType.formSchema) {
				const fieldValue = details[field.key];
				
				// Check required fields
				if (field.required && (fieldValue === undefined || fieldValue === null || fieldValue === '')) {
					throw new ForbiddenException(`Field '${field.label}' (${field.key}) is required`);
				}

				// Validate field types if value is provided
				if (fieldValue !== undefined && fieldValue !== null && fieldValue !== '') {
					switch (field.type) {
						case 'number':
							if (typeof fieldValue !== 'number' && isNaN(Number(fieldValue))) {
								throw new ForbiddenException(`Field '${field.label}' must be a number`);
							}
							details[field.key] = Number(fieldValue);
							break;
						case 'date':
							const dateValue = new Date(fieldValue);
							if (isNaN(dateValue.getTime())) {
								throw new ForbiddenException(`Field '${field.label}' must be a valid date`);
							}
							details[field.key] = dateValue;
							break;
						case 'checkbox':
							if (typeof fieldValue !== 'boolean') {
								throw new ForbiddenException(`Field '${field.label}' must be a boolean`);
							}
							break;
						case 'select':
							if (field.options && field.options.length > 0 && !field.options.includes(fieldValue)) {
								throw new ForbiddenException(`Field '${field.label}' must be one of: ${field.options.join(', ')}`);
							}
							break;
					}
				}
			}
		}

		const submittedAt = dto.submittedAt ? new Date(dto.submittedAt) : new Date();

		const created = await this.activityModel.create({
			studentId: new Types.ObjectId(user.studentId),
			activityTypeId: new Types.ObjectId(dto.activityTypeId),
			title: dto.title,
			description: dto.description,
			attachments: dto.attachments?.map((id) => new Types.ObjectId(id)) ?? [],
			location: dto.location,
			locationType: dto.locationType,
			details: details, // validated details object based on formSchema
			submittedAt,
			isPublic: dto.isPublic ?? false,
			skills: dto.skills ?? [],
			creditsEarned: dto.creditsEarned ?? 0,
			externalUrl: dto.externalUrl,
			status: 'PENDING',
		});

		// If a facultyId is explicitly provided at creation, create the assignment
		// via the ActivityAssignmentService (delegate DB work to that service).
		
		await this.activityAssignmentService.create({
			activityId: created._id.toString(),
			studentId: user.studentId!,
			instituteId: user.instituteId,
		});

		return created;
	}

	async findAll(user: JwtPayload, filters: FindActivitiesFilter = {}) {
		const query: any = {};

		if (filters.status) {
			query.status = filters.status;
		}
		if (filters.activityTypeId) {
			query.activityTypeId = new Types.ObjectId(filters.activityTypeId);
		}

		if (user.role === Role.Student) {
			query.studentId = new Types.ObjectId(user.studentId);
			return this.activityModel.find(query).exec();
		}

		if (user.role === Role.Faculty) {
			const assignments = await this.activityAssignmentModel
				.find({ facultyId: new Types.ObjectId(user.facultyId) })
				.select('activityId')
				.exec();
			const activityIds = assignments.map((a) => a.activityId);
			query._id = { $in: activityIds };
			return this.activityModel.find(query).exec();
		}

		// Admin: activities within institute via assignment table
		const instituteAssignments = await this.activityAssignmentModel
			.find({ instituteId: new Types.ObjectId(user.instituteId) })
			.select('activityId')
			.exec();
		const instActivityIds = instituteAssignments.map((a) => a.activityId);
		query._id = { $in: instActivityIds };
		return this.activityModel.find(query).exec();
	}

	async findOne(id: string, user: JwtPayload) {
		const activity = await this.activityModel.findById(id).exec();
		if (!activity) throw new NotFoundException('Activity not found');

		await this.ensureAccess(activity, user);
		return activity;
	}

	async update(id: string, dto: UpdateActivityDto, user: JwtPayload) {
		const activity = await this.activityModel.findById(id).exec();
		if (!activity) throw new NotFoundException('Activity not found');

		await this.ensureAccess(activity, user, dto.status);

		// prevent students from changing credits or status; already enforced in ensureAccess

		Object.assign(activity, dto);

		// if faculty is approving, enforce credit range based on activity type
		if (user.role === Role.Faculty && dto.status === 'APPROVED') {
			const activityType = await this.activityTypeModel
				.findById(activity.activityTypeId)
				.exec();

			if (!activityType) {
				throw new NotFoundException('Associated ActivityType not found');
			}

			const min = activityType.minCredit ?? 0;
			const max = activityType.maxCredit ?? 0;

			if (dto.creditsEarned == null) {
				throw new ForbiddenException('creditsEarned must be set when approving an activity');
			}

			if (dto.creditsEarned < min || (max > 0 && dto.creditsEarned > max)) {
				throw new ForbiddenException(
					`creditsEarned must be between ${min} and ${max > 0 ? max : 'no upper limit'}`,
				);
			}

			activity.creditsEarned = dto.creditsEarned;
			activity.approvedBy = new Types.ObjectId(user.facultyId);
			activity.approvedAt = new Date();
			activity.reviewedBy = new Types.ObjectId(user.facultyId);
			activity.reviewedAt = new Date();
		}
		return activity.save();
	}

	async remove(id: string, user: JwtPayload) {
		const activity = await this.activityModel.findById(id).exec();
		if (!activity) throw new NotFoundException('Activity not found');

		await this.ensureAccess(activity, user);

		await this.activityAssignmentModel.deleteOne({ activityId: activity._id }).exec();
		await activity.deleteOne();
		return { deleted: true };
	}

	private async ensureAccess(
		activity: ActivityDocument,
		user: JwtPayload,
		newStatus?: UpdateActivityDto['status'],
	) {
		if (user.role === Role.Student) {
			if (activity.studentId.toString() !== user.studentId) {
				throw new ForbiddenException('You can access only your own activities');
			}
			if (newStatus && newStatus !== activity.status) {
				throw new ForbiddenException('Students cannot change activity status');
			}
			return;
		}

		if (user.role === Role.Faculty) {
			const assignment = await this.activityAssignmentModel
				.findOne({ activityId: activity._id, facultyId: new Types.ObjectId(user.facultyId) })
				.exec();
			if (!assignment) {
				throw new ForbiddenException('You are not assigned to this activity');
			}
			// faculty can change status and credits (validated above)
			return;
		}

		// Admin: ensure same institute via assignment
		const adminAssignment = await this.activityAssignmentModel
			.findOne({ activityId: activity._id, instituteId: new Types.ObjectId(user.instituteId) })
			.exec();
		if (!adminAssignment) {
			throw new ForbiddenException('Activity not in your institute');
		}
	}
}

